<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>bulk: Титульная страница</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bulk
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="namespaces.html"><span>Пространства&#160;имен</span></a></li>
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">bulk Документация</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Использование bulk</h2>
<p>Реализация bulk выполнена в полном объеме согласно ДЗ.</p>
<p>bulk имеет опцию:</p>
<p><code>-N &lt;size&gt;</code> - <b>обязательный параметр</b>, задающий число команд в блоке.</p>
<p>Напимер:</p>
<p><code>bulk -N 3</code></p>
<p>запускает bulk с размером блока - в 3 команды</p>
<p>В случае возникновения ошибки, т.е. если встретится не парная } скобка, программа завершится по исключению</p>
<h2>Описание моей реализации bulk</h2>
<p>В основе реализации bulk лежит обобщенный паттерн Наблюдатель.</p>
<h3>Общее описание моей реализации паттерна Наблюдатель:</h3>
<p>Я изначально решил попробовать написать обобщенную версию паттерна Наблюдатель. Т.е. такую версию, которая может в качестве подписчика использовать любую ф-ию или ф-альный объект с подходящей сигнатурой.</p>
<p>В процессе написания кода, я столкнулся с рядом сложностей, и поиск в гугле дал эту статью Herb Sutter <a href="http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2003/0309/cujexp0309sutter/">http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/CUJ/2003/0309/cujexp0309sutter/</a></p>
<p>В этой статье, написанной 2003, Herb Sutter предложил идею реализации обобщенного паттерна Наблюдатель. Моя реализация фактически является аналогом идеи Herb Sutter и имеет те же проблемы, что и проблемы, с которыми столкнулся Sutter.</p>
<p>Ключевой проблемой, является ограниченность функциональности std::function. Sutter даже предлагал в статье внести изменения в стандарт, чтобы решить эту проблему. Но несмотря на то, что прошло более 10 лет все проблемы остались на прежнем месте.</p>
<p>Суть проблемы в том, что сложно создать множество объектов std::function, без дубликатов. Поскольку function не имеет операторов сравнения ==, !=, &lt;, &gt;, &lt;=, &gt;=. (Если бы я заранее был бы знаком с этой статьей, я бы не взялся за обобщенный подход. Решив, что он не реализуем в принципе в рамках текущего стандарта.)</p>
<p>Для решения этой проблемы, пришлось сделать обвязку вокруг function, т.е. хранить вместе с std::function исходные(оригинальные) адреса функциональных объектов и функций. Таким образом вместо std::set использовать std::unordered_map, где в качестве ключа и использовать эти адреса.</p>
<p>std::unordered_map использует для сравнения элементов(ключей) оператор ==. Это позволяет обойти проблему отсутствия операторов сравнения у самого std::function. Но порождает другие сложности, связанные с универсальным представлением адресов различных объектов в С++</p>
<p>Например, указатель на функцию в общем случае не может быть приведен к типу void* (т.е. указателю на объекты) [C++17 8.2.10/8]. Поэтому пришлось хранить указатели на функции и указатели на функциональные объекты, как независимые сущности в std::variant. И в этом смысле С++17 все же помогает решить проблему.</p>
<p>Так же пришлось использовать reinterpret_cast для приведения указателей на ф-ии с разными сигнатурами к указателю на ф-ию с одной сигнатурой void(*)(void). Аналогично поступить для указателей на функции члены класса. Поскольку после преобразования, мы не будем пытаться вызвать ф-ии, а лишь сравниваем числовые значения адресов, то это не вызовет неопределенного поведения. Соответствующие комментарии со ссылками на стандарт, допускающими такое преобразование и использование, имеются в коде.</p>
<h3>Более детальное описание моей реализации паттерна Наблюдатель:</h3>
<p>1) В задании было сказано: использовать паттерн “наблюдатель”, он призван снизить связанность классов в программе, и желательно именно это и получить. Т.е. низкую связность обработки данных.<br/>
<br/>
 В связи с этим, я отказался от классической схемы наследования subscribers от абстрактного интерфейсного класса. От своих подписчиков publisher этого не требует. Единственно, чего требует publisher от подписчиков, чтобы они имели одну и туже сигнатуру ф-ии уведомления, т.е. один и тот же тип возвращаемого значения, одинаковое количество и типы аргументов.<br/>
<br/>
 Таким образом, у меня получилась реализация Обобщенного паттерна Наблюдатель.<br/>
<br/>
 Сигнатуры подписчиков задается через параметр шаблона класса publisher. Например:</p>
<div class="fragment"><div class="line">publisher_mixin&lt;void(const std::vector&lt;std::string&gt;&amp;, std::time_t)&gt;</div>
</div><!-- fragment --><p>задает подписчиков с двумя параметрами&lt;br&gt;<br/>
 Вообще говоря, на сигнатуру подписчиков наложено лишь одно ограничение, количество аргументов не может быть больше 20. Это связано с количеством placeholders в используемых реализациях стандартной библиотеки</p>
<p>3) Таким образом, подписчиками могут быть любые ф-ии и функциональные объекты, с любым типом возвращаемого значения и аргументов.<br/>
<br/>
 Например, подписываем функциональные объекты с сигнатурой <code>void(void)</code> :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> fn(){}</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>subscriber</div>
<div class="line">{</div>
<div class="line">      <span class="keywordtype">void</span> test(){};</div>
<div class="line">      <span class="keywordtype">void</span> operator()(){}</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">subscriber sscr;</div>
<div class="line"></div>
<div class="line">pbl.subscribe(fn);                        <span class="comment">// подписываем ф-ию</span></div>
<div class="line">pbl.subscribe(sscr);                      <span class="comment">// подписываем subscriber::operator()</span></div>
<div class="line">pbl.subscribe(sscr, &amp;subscriber::test);   <span class="comment">// подписываем subscriber::test()</span></div>
<div class="line">pbl.subscribe([]() { <span class="keywordtype">int</span> i = 1; i++; });  <span class="comment">// подписываем Лямбду</span></div>
</div><!-- fragment --><p>4) В классе <b>publisher_mixin</b> так же добавлена возможность отписаться от уведомления.<br/>
 Для этого функция добавления подписчика возвращает дескриптор, который затем нужно передать ф-ии удаления подписчика:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> handle = pbl.subscribe(subscriber_taged(1), &amp;subscriber_taged::test1);</div>
<div class="line">pbl.unsubscribe(handle);</div>
</div><!-- fragment --><p>Можно так же отписаться от всех подписчиков:</p>
<div class="fragment"><div class="line">pbl.unsubscribe_all();</div>
</div><!-- fragment --><p>5) &gt; <b>lvalue</b> функторы сохраняются по ссылке, что позволяет из ф-ии уведомления изменять состояние исходного объекта подписчика.<br/>
<br/>
 &gt; <b>rvalue</b> функторы сохраняются по значению, чтобы они имели возможность после подписки дожить до вызова ф-ии уведомления.</p>
<p>6) Особенности <b>publisher_mixin</b><br/>
 Класс *по умолчанию* сохраняет только уникальных подписчиков, т.е. все подписчики получат уведомления только один раз.<br/>
<br/>
 Для достижения этого пришлось пойти на ряд жертв, в частности, подписчики этого класса *по умолчанию* не могут иметь множественное и/или виртуальное наследование.<br/>
<br/>
 Но если хочется, то все эти ограничения можно снять. Если мы хотим добавить подписчика с множественным и виртуальным наследованием, то делаем так:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>subscriber_md : subscriber_base1, subscriber_base2</div>
<div class="line">{</div>
<div class="line">      <span class="keywordtype">void</span> test2(){};</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">publisher pbl;</div>
<div class="line">pbl.subscribe(std::bind(&amp;subscriber_md::test2, md));</div>
</div><!-- fragment --><p>При желании, мы так же можем подписать один и тот же функциональный объект несколько раз.<br/>
 Если это обычная ф-ия, то так:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> subscriber_fn(){}</div>
<div class="line"></div>
<div class="line">pbl.subscribe(std::function&lt;<span class="keywordtype">void</span>(<span class="keywordtype">void</span>)&gt;(subscriber_fn));</div>
<div class="line">pbl.subscribe(std::function&lt;<span class="keywordtype">void</span>(<span class="keywordtype">void</span>)&gt;(subscriber_fn));</div>
</div><!-- fragment --><p>Если это ф-ия член класса, то так:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>subscriber</div>
<div class="line">{</div>
<div class="line">      <span class="keywordtype">void</span> test0(){};</div>
<div class="line">};</div>
<div class="line">subscriber sscrb;</div>
<div class="line"></div>
<div class="line">pbl.subscribe(std::bind(&amp;subscriber::test0, sscrb)); </div>
<div class="line">pbl.subscribe(std::bind(&amp;subscriber::test0, sscrb)); </div>
</div><!-- fragment --><p>7) В целях снижения связности publisher класс сделан в виде mixin класса: <b>publisher_mixin</b><br/>
 Таким образом мы можем добавить его, как базовый класс, в любой другой класс, что автоматически добавит функциональность паттерна <code>наблюдатель</code> в полученный класс.<br/>
<br/>
 Все, что останется сделать в полученном классе, вызвать ф-ию <code>notify()</code>, передав ей обновленные данные.</p>
<p>8) Если ф-ия подписчика возвращает значение, то ф-ию <code>notify()</code>собирает эти значения и возвращает список пар: возвращаемое значение, дескриптор ф-ии - который однозначно задает ф-ию подписчика.<br/>
<br/>
 На основании этого дескриптора, мы можем отписать ф-ию подписчика или, вызвав get_fn_by_handle() получить объект function&lt;R(Args...)&gt;, инкапсулирующий ф-ию подписчика.<br/>
 Например:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Base = publisher_mixin&lt;<span class="keywordtype">int</span>(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>)&gt;&gt;</div>
<div class="line"><span class="keyword">struct </span>publisher_not_void : <span class="keyword">public</span> Base</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> Base::notify;</div>
<div class="line">    <span class="keyword">using</span> Base::get_fn_by_handle;</div>
<div class="line">    <span class="keyword">using</span> Base::get_last_notify_exception;</div>
<div class="line"></div>
<div class="line">    <span class="keyword">using</span> notify_ret_t = std::invoke_result_t&lt;decltype(&amp;publisher_not_void::notify), Base, int, int&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    notify_ret_t retvs;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">int</span> run()</div>
<div class="line">    {</div>
<div class="line">            <span class="keywordtype">int</span> sum = 0;</div>
<div class="line">            retvs = notify(1, 1);</div>
<div class="line"></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; retv : retvs)</div>
<div class="line">            {</div>
<div class="line">                sum += retv.first;                        </div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">return</span> sum;</div>
<div class="line">    };</div>
<div class="line">};</div>
</div><!-- fragment --><p>9) Обраотка исключений организована в стиле С++11. В классе <b>publisher_mixin</b> реализован перехват исключений, которые могут возникнуть у подписчиков во время уведомления. Все собранные во время последнего уведомления исключения можно получить в классе наследнике от <b>publisher_mixin</b>, через ф-ию:</p>
<div class="fragment"><div class="line"><a class="code" href="classroro__lib_1_1exception__ptr__list.html">roro_lib::exception_ptr_list</a> notify_exception_list = get_last_notify_exception();</div>
</div><!-- fragment --><p>Если список пуст, то при последнем уведомлении подписчики не бросали исключений.</p>
<p>Для удобства полученный список, если он не пуст, можно бросить, как исключение: </p>
<div class="fragment"><div class="line">notify_exception_list.<a class="code" href="classroro__lib_1_1exception__ptr__list.html#ade70a613f362092455946ab7fb5cf72b">rethrow_if_exist</a>();</div>
</div><!-- fragment --><p>И перехватить его уже в выше лежащих обработчиках исключений.</p>
<p>Репозиторий можно найти здесь: <a href="https://rra-roro.github.io/homework_7_bulk/index.html">https://rra-roro.github.io/homework_7_bulk/index.html</a> </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
