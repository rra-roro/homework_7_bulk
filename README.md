# Otus homework 7: bulk

## Особенности моей реализации следующие:

0) Функциональность основного задания выполнена в полном объеме.<br>
   В случае возникновения ошибки, т.е. если встретится не парная } скобка,<br>
   программа завершится по исключению

1)	Было реализовано два варианта – два класса publisher:
> **publisher_unique_mixin** – хранит уникальных подписчиков<br>
> **publisher_multi_mixin** – хранит не уникальных подписчиков

2)	В задании было сказано: использовать паттерн “наблюдатель”, он призван снизить связанность <br>
классов в программе, и желательно именно это и получить. Т.е. низкую связность обработки данных.
В связи с этим, я отказался от классической схемы наследования subscribers от абстрактного <br>
интерфейсного класса. От своих подписчиков publisher этого не требует. Единственно, чего требует <br>
publisher от подписчиков, чтобы они имели одну и туже сигнатуру ф-ии уведомления, т.е. один и <br>
тот же тип возвращаемого значения, одинаковое количество и типы аргументов.  
Сигнатуры подписчиков задается через параметр шаблона класса publisher. Например:
```cpp
     publisher_unique_mixin<void(const std::vector<std::string>&, std::time_t)>
```
задает подписчиков с двумя параметрами

Вообще говоря, на сигнатуру подписчиков наложено лишь одно ограничение, количество <br>
аргументов не может быть больше 20. Это связано с количеством placeholders <br>
в используемых реализациях стандартной библиотеки

3)	Таким образом, подписчиками могут быть любые ф-ии и функциональные объекты, <br>
с любым типом возвращаемого значения и аргументов.<br>
Например, подписываем функциональные объекты с сигнатурой `void(void)`:
```cpp
void fn(){}

struct subscriber
{
      void test(){};
      void operator()(){}
};

subscriber sscr;

pbl.add_subscriber(fn);                       // подписываем ф-ию
pbl.add_subscriber(sscr);                     // подписываем subscriber::operator()
pbl.add_subscriber(sscr, &subscriber::test);  // подписываем subscriber::test()

```

4)	>lvalue функторы сохраняются по ссылке, что позволяет из ф-ии уведомления <br>
    изменять состояние исходного объекта подписчика.<br>
    >rvalue функторы сохраняются по значению, чтобы они имели возможность после <br>
    подписки дожить до вызова ф-ии уведомления.

5)	В целях снижения связности publisher классы сделаны в виде mixin классов. Таким образом мы <br>
    можем добавить их, как базовый класс, в любой другой класс, что автоматически добавит <br>
    функциональность паттерна `наблюдатель` в полученном классе. Все, что останется сделать <br>
    в полученном классе, вызвать ф-ию `notify()`, передав ей обновленные данные.

6)  Особенности **publisher_unique_mixin**<br>
    Класс сохраняет только уникальных подписчиков, т.е. все подписчики получат <br>
    уведомления только один раз.<br>
    Для достижения этого пришлось пойти на ряд жертв, в частности, подписчики этого <br>
    класса не могут иметь множественное и/или виртуальное наследование.

6)  Особенности **publisher_multi_mixin**<br>
    Класс сохраняет всех подписчиков, т.е. все подписчики получат <br>
    уведомления столько раз, сколько раз они были подписаны.<br>
    Но зато нет ограничений на множественное и виртуальное наследование.

    
Документацию и дополнительное описание проекта можно найти здесь:
https://rra-roro.github.io/homework_7_bulk
